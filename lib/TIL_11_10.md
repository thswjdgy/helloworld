# 캡슐화 

## 캡슐화가 적용되지 않은 코드

class User {
  String name = "";
  int age = 0;
}

void main() {
  var user = User();
  user.name = '홍길동';
  user.age = -5; // 나이에 음수를 넣어도 막을 수 없음
  print('${user.name}, ${user.age}');
}

## 캡슐화가 적용된 코드

class User {
  final String _name;
  final int _age;

  // getter는 private 필드에 접근해야 함
  String get name => _name;
  int get age => _age;

  // 생성자를 통해 초기화
  User(this._name, this._age);
}

void main() {
  var user = User("홍길동", 25);

  // user.age = 20; // ❌ 오류 발생: final 필드는 수정 불가

  print('${user.name}, ${user.age}');
}

# 상속

## 상속예제 

// 부모 클래스
class Animal {
  void eat() {
    print("동물이 먹고 있습니다.");
  }
}

// 자식 클래스
class Dog extends Animal {
  void bark() {
    print("멍멍!");
  }
}

void main() {
  var dog = Dog();

  dog.eat();   // 부모 클래스의 메서드 사용 가능
  dog.bark();  // 자식 클래스에서 추가한 메서드
}

# 다형성

## 다형성 예제 코드

// 부모 클래스
class Animal {
  void makeSound() {
    print("동물이 소리를 냅니다.");
  }
}

// 자식 클래스 1
class Dog extends Animal {
  @override
  void makeSound() {
    print("멍멍!");
  }
}

// 자식 클래스 2
class Cat extends Animal {
  @override
  void makeSound() {
    print("야옹!");
  }
}

void main() {
  // 부모 타입으로 여러 자식 객체를 참조
  List<Animal> animals = [Dog(), Cat(), Animal()];

  for (var animal in animals) {
    animal.makeSound(); 
    // Dog -> 멍멍!
    // Cat -> 야옹!
    // Animal -> 동물이 소리를 냅니다.
  }
}

# 추상화

## 추상화 + 상속 + 다형성 코드 완성본

// 추상 클래스 (부모)
abstract class Animal {
  final String _name;
  String get name => _name;

  Animal(this._name);

  // 추상 메서드: 자식 클래스가 반드시 구현해야 함
  void makeSound();
}

// 자식 클래스 1
class Dog extends Animal {
  Dog(String name) : super(name);

  @override
  void makeSound() {
    print("$name: 월월!");
  }
}

// 자식 클래스 2
class Cat extends Animal {
  Cat(String name) : super(name);

  @override
  void makeSound() {
    print("$name: 냐옹!");
  }
}

void main() {
  // 객체를 직접 리스트에 넣기
  List<Animal> animals = [Dog("바둑이"), Cat("냥이")];

  for (var animal in animals) {
    animal.makeSound();
    // 출력:
    // 바둑이: 월월!
    // 냥이: 냐옹!
  }
}


## Dart OOP 예제 코드

// ---------------- 캡슐화 ----------------
class BankAccount {
  double _balance = 0; // 비공개 필드

  BankAccount([double initialBalance = 0]) {
    if (initialBalance < 0) throw ArgumentError('음수 잔액 불가');
    _balance = initialBalance;
  }

  double get balance => _balance; // 읽기 전용 게터

  void deposit(double amount) {
    if (amount <= 0) throw ArgumentError('입금액은 양수여야 함');
    _balance += amount;
  }

  void withdraw(double amount) {
    if (amount > _balance) throw StateError('잔액 부족');
    _balance -= amount;
  }
}

// ---------------- 상속 ----------------
class Vehicle {
  final String model;
  Vehicle(this.model);

  void start() => print('$model 시동 켬');
}

class Car extends Vehicle {
  Car(super.model);

  @override
  void start() {
    super.start();
    print('$model 주행 준비 완료');
  }
}

// ---------------- 다형성 ----------------
abstract class PaymentProcessor {
  void pay(int amount);
}

class CardProcessor implements PaymentProcessor {
  @override
  void pay(int amount) => print('카드로 $amount원 결제');
}

class CashProcessor implements PaymentProcessor {
  @override
  void pay(int amount) => print('현금으로 $amount원 결제');
}

void checkout(PaymentProcessor processor, int amount) {
  processor.pay(amount);
}

// ---------------- 추상화 ----------------
abstract class Shape {
  double area();
}

class Rectangle implements Shape {
  final double w, h;
  Rectangle(this.w, this.h);

  @override
  double area() => w * h;
}

class Circle implements Shape {
  final double r;
  Circle(this.r);

  @override
  double area() => 3.14159 * r * r;
}

// ---------------- main ----------------
void main() {
  // 캡슐화
  final account = BankAccount(100);
  account.deposit(50);
  print('잔액: ${account.balance}');

  // 상속
  final car = Car('Avante');
  car.start();

  // 다형성
  checkout(CardProcessor(), 50000);
  checkout(CashProcessor(), 30000);

  // 추상화
  final shapes = [Rectangle(3, 4), Circle(5)];
  for (var s in shapes) {
    print('면적: ${s.area()}');
  }
}

ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
## 클래스 : 객체를 만들기 위한 툴

## 객체(Object)	: 클래스에서 만들어진 ‘실제 인스턴스’. 속성과 메서드를 가진 독립적인 단위

## 생성자(Constructor) : 객체가 생성될 때 호출되는 특별한 메서드. 초기화 담당

## 캡슐화(Encapsulation) : 데이터와 동작을 클래스 내부에 숨기고, 외부에는 필요한 인터페이스만 제공

## 상속(Inheritance) : 부모 클래스의 속성과 메서드를 자식 클래스가 이어받아 확장

## 다형성(Polymorphism) : 같은 인터페이스를 구현한 클래스가 서로 다른 방식으로 동작

## 추상화(Abstraction) : 공통 규약만 정의하고, 구체 구현은 하위 클래스에서 담당


## 인터페이스(Interface) : 클래스가 반드시 구현해야 할 규약을 정의. implements로 사용

## Mixin : 여러 클래스에 공통 기능을 쉽게 재사용할 수 있는 도구

------------------------------

# 인터페이스 (Interface)
## 장점
## 규약 강제: 특정 메서드/속성을 반드시 구현하도록 강제 → 일관성 유지

## 다형성 지원: 같은 인터페이스를 구현한 클래스는 상위 타입으로 묶어 처리 가능 → 유연한 설계

## 유연성: 상속 없이도 다양한 클래스에 동일한 규약 적용 가능

## 단점
## 구현 부담: 모든 메서드를 직접 구현해야 하므로 코드량 증가

## 기본 구현 불가: Dart 인터페이스는 기본 로직을 제공하지 못함 (Java의 default method와 달리)

## 추상화 난이도: 잘못된 인터페이스 설계는 오히려 복잡성을 높임


# 믹스인 (Mixin)
## 장점
## 코드 재사용: 여러 클래스에 동일한 기능을 쉽게 추가 가능

## 다중 상속 대체: Dart는 단일 상속만 지원 → mixin으로 여러 기능을 조합 가능

## 유연한 확장: 기존 클래스 구조를 바꾸지 않고 기능을 덧붙일 수 있음

## 단점
## 남용 위험: 너무 많은 mixin을 붙이면 클래스 역할이 모호해짐

## 충돌 가능성: 서로 다른 mixin이 같은 메서드 이름을 정의하면 충돌 발생

## 의존성 증가: mixin 내부에서 특정 필드/메서드를 기대하면 적용 클래스가 이를 반드시 제공해야 함
